
path = /scratch/rabin/data/code2vec/transforms/Methods_Test/java-large/test/yahoo__FEL/src/main/java/it/cnr/isti/hpc/Word2VecCompress_main.java
method_name = main
method_body = public static void main(String[] args) throws Exception { SimpleJSAP jsap = new SimpleJSAP(Word2VecCompress.class.getName(), "Creates a compressed representation of quantized word2vec vectors", new Parameter[] { new UnflaggedOption("input", JSAP.STRING_PARSER, true, "Input file"), new UnflaggedOption("output", JSAP.STRING_PARSER, false, "Compressed version"), new Switch("check", JSAP.NO_SHORTFLAG, "check", "Check correctness of output") }); JSAPResult jsapResult = jsap.parse(args); if (jsap.messagePrinted()) return; String input_filename = jsapResult.getString("input"); String output_filename = jsapResult.getString("output", null); int numWords, vectorSize; float quantizationFactor; List<String> indexToWord; int[] entries; long[] columnAbsSum; ProgressLogger pl = new ProgressLogger(logger); try (final BufferedReader lines = new BufferedReader(new FileReader(input_filename))) { String[] header = lines.readLine().split("\t"); numWords = Integer.parseInt(header[0]); vectorSize = Integer.parseInt(header[1]); quantizationFactor = Float.parseFloat(header[2]); pl.expectedUpdates = numWords; pl.start("Reading the dictionary"); indexToWord = new ArrayList<>(); for (int i = 0; i < numWords; ++i) { pl.lightUpdate(); indexToWord.add(lines.readLine().trim()); } pl.done(); entries = new int[numWords * vectorSize]; columnAbsSum = new long[vectorSize]; pl.expectedUpdates = numWords; pl.start("Reading the vectors"); for (int i = 0; i < numWords; ++i) { pl.lightUpdate(); String[] lineEntries = lines.readLine().split(" "); for (int col = 0; col < vectorSize; ++col) { int entry = Integer.parseInt(lineEntries[col]); entries[i * vectorSize + col] = entry; columnAbsSum[col] += Fast.int2nat(entry) + 1; } } pl.done(); } int[] golombModuli = new int[vectorSize]; for (int col = 0; col < vectorSize; ++col) { int m = 0; if (columnAbsSum[col] > numWords) { double f = ((double) numWords) / columnAbsSum[col]; m = (int) Math.ceil(Math.log(2.0 - f) / -Math.log(1.0 - f)); } golombModuli[col] = m; } ShiftAddXorSignedStringMap dictionaryHash = new ShiftAddXorSignedStringMap(indexToWord.iterator(), new MinimalPerfectHashFunction.Builder<CharSequence>().keys(indexToWord).transform(TransformationStrategies.utf16()).build()); int[] permutation = new int[numWords]; for (int i = 0; i < numWords; ++i) { int newPos = dictionaryHash.get(indexToWord.get(i)).intValue(); permutation[newPos] = i; } FastByteArrayOutputStream oa = new FastByteArrayOutputStream(); OutputBitStream obs = new OutputBitStream(oa, 0); final LongArrayList endpoints = new LongArrayList(); pl.expectedUpdates = numWords; pl.start("Compressing the vectors"); for (int i = 0; i < numWords; ++i) { pl.lightUpdate(); endpoints.add(obs.writtenBits()); int rowStart = permutation[i] * vectorSize; for (int col = 0; col < vectorSize; ++col) { int entry = entries[rowStart + col]; obs.writeGolomb(Fast.int2nat(entry), golombModuli[col]); } } pl.done(); obs.close(); while (oa.length() % 4 != 0) { oa.write(0); } oa.trim(); double bps = 8.0 * oa.array.length / entries.length; logger.info("Overall vector bit streams: {} bytes, {} bps", oa.array.length, bps); System.out.println(bps); EliasFanoMonotoneLongBigList efEndpoints = new EliasFanoMonotoneLongBigList(endpoints); Word2VecCompress word2vec = new Word2VecCompress(numWords, vectorSize, quantizationFactor, oa.array, efEndpoints, dictionaryHash, golombModuli); if (output_filename != null) { BinIO.storeObject(word2vec, output_filename); } if (jsapResult.getBoolean("check")) { pl.expectedUpdates = numWords; pl.start("Checking the output"); for (int i = 0; i < numWords; ++i) { pl.lightUpdate(); int[] vec = word2vec.getInt(indexToWord.get(i)); for (int col = 0; col < vectorSize; ++col) { int expected = entries[i * vectorSize + col]; int got = vec[col]; if (expected != got) { logger.error("Row {}, Column {}: Expected {}, got {}", i, col, expected, got); System.exit(1); } } } pl.done(); } }

topk path-contexts:
[0.3796] string,(ClassOrInterfaceType1)^(Parameter)_(ArrayBracketPair2),[]
[0.0709] args,(VariableDeclaratorId0)^(Parameter)^(MethodDeclaration)_(BlockStmt)_(ExpressionStmt)_(VariableDeclarationExpr)_(VariableDeclarator)_(ArrayCreationExpr)_(PrimitiveType1),int
[0.0557] args,(VariableDeclaratorId0)^(Parameter)^(MethodDeclaration)_(BlockStmt)_(ExpressionStmt)_(MethodCallExpr0)_(NameExpr0),logger
[0.0526] args,(VariableDeclaratorId0)^(Parameter)^(MethodDeclaration)_(BlockStmt)_(IfStmt)_(BinaryExpr:notEquals)_(NameExpr0),outputfilename
[0.0332] args,(VariableDeclaratorId0)^(Parameter)^(MethodDeclaration)_(ClassOrInterfaceType3),exception
[0.0252] args,(VariableDeclaratorId0)^(Parameter)^(MethodDeclaration)_(BlockStmt)_(ExpressionStmt)_(VariableDeclarationExpr)_(VariableDeclarator)_(ObjectCreationExpr)_(ClassOrInterfaceType0),wordveccompress
[0.0227] args,(VariableDeclaratorId0)^(Parameter)^(MethodDeclaration)_(BlockStmt)_(ExpressionStmt)_(VariableDeclarationExpr)_(VariableDeclarator)_(VariableDeclaratorId0),numwords
[0.0224] args,(VariableDeclaratorId0)^(Parameter)^(MethodDeclaration)_(BlockStmt)_(ForStmt)_(BlockStmt)_(ExpressionStmt)_(MethodCallExpr0)_(NameExpr3),add
[0.0209] METHOD_NAME,(NameExpr1)^(MethodDeclaration)_(ClassOrInterfaceType3),exception
[0.0166] args,(VariableDeclaratorId0)^(Parameter)^(MethodDeclaration)_(BlockStmt)_(TryStmt)_(BlockStmt)_(ExpressionStmt)_(MethodCallExpr0)_(NameExpr0),pl

topk terminals:
['string', '[]', 'args', 'int', 'args', 'logger', 'args', 'outputfilename', 'args', 'exception', 'args', 'wordveccompress', 'args', 'numwords', 'args', 'add', 'METHOD_NAME', 'exception', 'args', 'pl']

