
path = /scratch/rabin/data/code2vec/transforms/Methods_Test/java-large/test/yahoo__FEL/src/main/java/it/cnr/isti/hpc/Word2VecCompress_main.java
method_name = main
method_body = public static void main(String[] args) throws Exception { SimpleJSAP jsap = new SimpleJSAP(Word2VecCompress.class.getName(), "Creates a compressed representation of quantized word2vec vectors", new Parameter[] { new UnflaggedOption("input", JSAP.STRING_PARSER, true, "Input file"), new UnflaggedOption("output", JSAP.STRING_PARSER, false, "Compressed version"), new Switch("check", JSAP.NO_SHORTFLAG, "check", "Check correctness of output") }); JSAPResult jsapResult = jsap.parse(args); if (jsap.messagePrinted()) return; String input_filename = jsapResult.getString("input"); String output_filename = jsapResult.getString("output", null); int numWords, vectorSize; float quantizationFactor; List<String> indexToWord; int[] entries; long[] columnAbsSum; ProgressLogger pl = new ProgressLogger(logger); try (final BufferedReader lines = new BufferedReader(new FileReader(input_filename))) { String[] header = lines.readLine().split("\t"); numWords = Integer.parseInt(header[0]); vectorSize = Integer.parseInt(header[1]); quantizationFactor = Float.parseFloat(header[2]); pl.expectedUpdates = numWords; pl.start("Reading the dictionary"); indexToWord = new ArrayList<>(); for (int i = 0; i < numWords; ++i) { pl.lightUpdate(); indexToWord.add(lines.readLine().trim()); } pl.done(); entries = new int[numWords * vectorSize]; columnAbsSum = new long[vectorSize]; pl.expectedUpdates = numWords; pl.start("Reading the vectors"); for (int i = 0; i < numWords; ++i) { pl.lightUpdate(); String[] lineEntries = lines.readLine().split(" "); for (int col = 0; col < vectorSize; ++col) { int entry = Integer.parseInt(lineEntries[col]); entries[i * vectorSize + col] = entry; columnAbsSum[col] += Fast.int2nat(entry) + 1; } } pl.done(); } int[] golombModuli = new int[vectorSize]; for (int col = 0; col < vectorSize; ++col) { int m = 0; if (columnAbsSum[col] > numWords) { double f = ((double) numWords) / columnAbsSum[col]; m = (int) Math.ceil(Math.log(2.0 - f) / -Math.log(1.0 - f)); } golombModuli[col] = m; } ShiftAddXorSignedStringMap dictionaryHash = new ShiftAddXorSignedStringMap(indexToWord.iterator(), new MinimalPerfectHashFunction.Builder<CharSequence>().keys(indexToWord).transform(TransformationStrategies.utf16()).build()); int[] permutation = new int[numWords]; for (int i = 0; i < numWords; ++i) { int newPos = dictionaryHash.get(indexToWord.get(i)).intValue(); permutation[newPos] = i; } FastByteArrayOutputStream oa = new FastByteArrayOutputStream(); OutputBitStream obs = new OutputBitStream(oa, 0); final LongArrayList endpoints = new LongArrayList(); pl.expectedUpdates = numWords; pl.start("Compressing the vectors"); for (int i = 0; i < numWords; ++i) { pl.lightUpdate(); endpoints.add(obs.writtenBits()); int rowStart = permutation[i] * vectorSize; for (int col = 0; col < vectorSize; ++col) { int entry = entries[rowStart + col]; obs.writeGolomb(Fast.int2nat(entry), golombModuli[col]); } } pl.done(); obs.close(); while (oa.length() % 4 != 0) { oa.write(0); } oa.trim(); double bps = 8.0 * oa.array.length / entries.length; logger.info("Overall vector bit streams: {} bytes, {} bps", oa.array.length, bps); System.out.println(bps); EliasFanoMonotoneLongBigList efEndpoints = new EliasFanoMonotoneLongBigList(endpoints); Word2VecCompress word2vec = new Word2VecCompress(numWords, vectorSize, quantizationFactor, oa.array, efEndpoints, dictionaryHash, golombModuli); if (output_filename != null) { BinIO.storeObject(word2vec, output_filename); } if (jsapResult.getBoolean("check")) { pl.expectedUpdates = numWords; pl.start("Checking the output"); for (int i = 0; i < numWords; ++i) { pl.lightUpdate(); int[] vec = word2vec.getInt(indexToWord.get(i)); for (int col = 0; col < vectorSize; ++col) { int expected = entries[i * vectorSize + col]; int got = vec[col]; if (expected != got) { logger.error("Row {}, Column {}: Expected {}, got {}", i, col, expected, got); System.exit(1); } } } pl.done(); } }

Trace of simplified code(s):

{"time": "2021-01-25 14:59:27.116477", "score": "0.9964", "loss": "0.0087", "code": "class T { public static void main(String[] args) throws Exception { SimpleJSAP jsap = new SimpleJSAP(Word2VecCompress.class.getName(), \"Creates a compressed representation of quantized word2vec vectors\", new Parameter[] { new UnflaggedOption(\"input\", JSAP.STRING_PARSER, true, \"Input file\"), new UnflaggedOption(\"output\", JSAP.STRING_PARSER, false, \"Compressed version\"), new Switch(\"check\", JSAP.NO_SHORTFLAG, \"check\", \"Check correctness of output\") }); JSAPResult jsapResult = jsap.parse(args); if (jsap.messagePrinted()) return; String input_filename = jsapResult.getString(\"input\"); String output_filename = jsapResult.getString(\"output\", null); int numWords, vectorSize; float quantizationFactor; List<String> indexToWord; int[] entries; long[] columnAbsSum; ProgressLogger pl = new ProgressLogger(logger); try (final BufferedReader lines = new BufferedReader(new FileReader(input_filename))) { String[] header = lines.readLine().split(\"\t\"); numWords = Integer.parseInt(header[0]); vectorSize = Integer.parseInt(header[1]); quantizationFactor = Float.parseFloat(header[2]); pl.expectedUpdates = numWords; pl.start(\"Reading the dictionary\"); indexToWord = new ArrayList<>(); for (int i = 0; i < numWords; ++i) { pl.lightUpdate(); indexToWord.add(lines.readLine().trim()); } pl.done(); entries = new int[numWords * vectorSize]; columnAbsSum = new long[vectorSize]; pl.expectedUpdates = numWords; pl.start(\"Reading the vectors\"); for (int i = 0; i < numWords; ++i) { pl.lightUpdate(); String[] lineEntries = lines.readLine().split(\" \"); for (int col = 0; col < vectorSize; ++col) { int entry = Integer.parseInt(lineEntries[col]); entries[i * vectorSize + col] = entry; columnAbsSum[col] += Fast.int2nat(entry) + 1; } } pl.done(); } int[] golombModuli = new int[vectorSize]; for (int col = 0; col < vectorSize; ++col) { int m = 0; if (columnAbsSum[col] > numWords) { double f = ((double) numWords) / columnAbsSum[col]; m = (int) Math.ceil(Math.log(2.0 - f) / -Math.log(1.0 - f)); } golombModuli[col] = m; } ShiftAddXorSignedStringMap dictionaryHash = new ShiftAddXorSignedStringMap(indexToWord.iterator(), new MinimalPerfectHashFunction.Builder<CharSequence>().keys(indexToWord).transform(TransformationStrategies.utf16()).build()); int[] permutation = new int[numWords]; for (int i = 0; i < numWords; ++i) { int newPos = dictionaryHash.get(indexToWord.get(i)).intValue(); permutation[newPos] = i; } FastByteArrayOutputStream oa = new FastByteArrayOutputStream(); OutputBitStream obs = new OutputBitStream(oa, 0); final LongArrayList endpoints = new LongArrayList(); pl.expectedUpdates = numWords; pl.start(\"Compressing the vectors\"); for (int i = 0; i < numWords; ++i) { pl.lightUpdate(); endpoints.add(obs.writtenBits()); int rowStart = permutation[i] * vectorSize; for (int col = 0; col < vectorSize; ++col) { int entry = entries[rowStart + col]; obs.writeGolomb(Fast.int2nat(entry), golombModuli[col]); } } pl.done(); obs.close(); while (oa.length() % 4 != 0) { oa.write(0); } oa.trim(); double bps = 8.0 * oa.array.length / entries.length; logger.info(\"Overall vector bit streams: {} bytes, {} bps\", oa.array.length, bps); System.out.println(bps); EliasFanoMonotoneLongBigList efEndpoints = new EliasFanoMonotoneLongBigList(endpoints); Word2VecCompress word2vec = new Word2VecCompress(numWords, vectorSize, quantizationFactor, oa.array, efEndpoints, dictionaryHash, golombModuli); if (output_filename != null) { BinIO.storeObject(word2vec, output_filename); } if (jsapResult.getBoolean(\"check\")) { pl.expectedUpdates = numWords; pl.start(\"Checking the output\"); for (int i = 0; i < numWords; ++i) { pl.lightUpdate(); int[] vec = word2vec.getInt(indexToWord.get(i)); for (int col = 0; col < vectorSize; ++col) { int expected = entries[i * vectorSize + col]; int got = vec[col]; if (expected != got) { logger.error(\"Row {}, Column {}: Expected {}, got {}\", i, col, expected, got); System.exit(1); } } } pl.done(); } } }"}
{"time": "2021-01-25 15:01:55.375630", "score": "0.9999", "loss": "0.0001", "code": "class T { public static void main(String[] args) throws Exception { oa.write(0); } }"}
{"time": "2021-01-25 15:04:08.615156", "score": "0.9998", "loss": "0.0002", "code": "class T { public static void main(String args) throws Exception { oa.write(0); } }"}
{"time": "2021-01-25 15:04:48.003788", "score": "0.9753", "loss": "0.0287", "code": "class T { public static void main(String args) { oa.write(0); } }"}
{"time": "2021-01-25 15:05:27.579270", "score": "0.9753", "loss": "0.0287", "code": "class T { void main(String args) { oa.write(0); } }"}
{"time": "2021-01-25 15:06:07.090092", "score": "0.743", "loss": "0.3186", "code": "class T { void main(String args) { oa.write( ); } }"}

Minimal simplified code:
class T {
              void main(String   args)                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      { oa.write( ); }
}


