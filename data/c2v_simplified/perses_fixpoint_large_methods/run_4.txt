
path = /scratch/rabin/data/code2vec/transforms/Methods_Test/java-large/test/SummerRC__BiLiBiLi/OneXListviewLibrary/src/com/huewu/pla/lib/internal/PLA_AbsListView_run.java
method_name = run
method_body = public void run() { final int listHeight = getHeight(); final int firstPos = mFirstPosition; switch(mMode) { case MOVE_DOWN_POS: { final int lastViewIndex = getChildCount() - 1; final int lastPos = firstPos + lastViewIndex; if (lastViewIndex < 0) { return; } if (lastPos == mLastSeenPos) { post(this); return; } final View lastView = getChildAt(lastViewIndex); final int lastViewHeight = lastView.getHeight(); final int lastViewTop = lastView.getTop(); final int lastViewPixelsShowing = listHeight - lastViewTop; final int extraScroll = lastPos < mItemCount - 1 ? mExtraScroll : mListPadding.bottom; smoothScrollBy(lastViewHeight - lastViewPixelsShowing + extraScroll, mScrollDuration); mLastSeenPos = lastPos; if (lastPos < mTargetPos) { post(this); } break; } case MOVE_DOWN_BOUND: { final int nextViewIndex = 1; final int childCount = getChildCount(); if (firstPos == mBoundPos || childCount <= nextViewIndex || firstPos + childCount >= mItemCount) { return; } final int nextPos = firstPos + nextViewIndex; if (nextPos == mLastSeenPos) { post(this); return; } final View nextView = getChildAt(nextViewIndex); final int nextViewHeight = nextView.getHeight(); final int nextViewTop = nextView.getTop(); final int extraScroll = mExtraScroll; if (nextPos < mBoundPos) { smoothScrollBy(Math.max(0, nextViewHeight + nextViewTop - extraScroll), mScrollDuration); mLastSeenPos = nextPos; post(this); } else { if (nextViewTop > extraScroll) { smoothScrollBy(nextViewTop - extraScroll, mScrollDuration); } } break; } case MOVE_UP_POS: { if (firstPos == mLastSeenPos) { post(this); return; } final View firstView = getChildAt(0); if (firstView == null) { return; } final int firstViewTop = firstView.getTop(); final int extraScroll = firstPos > 0 ? mExtraScroll : mListPadding.top; smoothScrollBy(firstViewTop - extraScroll, mScrollDuration); mLastSeenPos = firstPos; if (firstPos > mTargetPos) { post(this); } break; } case MOVE_UP_BOUND: { final int lastViewIndex = getChildCount() - 2; if (lastViewIndex < 0) { return; } final int lastPos = firstPos + lastViewIndex; if (lastPos == mLastSeenPos) { post(this); return; } final View lastView = getChildAt(lastViewIndex); final int lastViewHeight = lastView.getHeight(); final int lastViewTop = lastView.getTop(); final int lastViewPixelsShowing = listHeight - lastViewTop; mLastSeenPos = lastPos; if (lastPos > mBoundPos) { smoothScrollBy(-(lastViewPixelsShowing - mExtraScroll), mScrollDuration); post(this); } else { final int bottom = listHeight - mExtraScroll; final int lastViewBottom = lastViewTop + lastViewHeight; if (bottom > lastViewBottom) { smoothScrollBy(-(bottom - lastViewBottom), mScrollDuration); } } break; } default: break; } }

Trace of simplified code(s):

{"time": "2021-01-25 15:23:14.660648", "score": "1.0", "loss": "0.0", "code": "class T { public void run() { final int listHeight = getHeight(); final int firstPos = mFirstPosition; switch(mMode) { case MOVE_DOWN_POS: { final int lastViewIndex = getChildCount() - 1; final int lastPos = firstPos + lastViewIndex; if (lastViewIndex < 0) { return; } if (lastPos == mLastSeenPos) { post(this); return; } final View lastView = getChildAt(lastViewIndex); final int lastViewHeight = lastView.getHeight(); final int lastViewTop = lastView.getTop(); final int lastViewPixelsShowing = listHeight - lastViewTop; final int extraScroll = lastPos < mItemCount - 1 ? mExtraScroll : mListPadding.bottom; smoothScrollBy(lastViewHeight - lastViewPixelsShowing + extraScroll, mScrollDuration); mLastSeenPos = lastPos; if (lastPos < mTargetPos) { post(this); } break; } case MOVE_DOWN_BOUND: { final int nextViewIndex = 1; final int childCount = getChildCount(); if (firstPos == mBoundPos || childCount <= nextViewIndex || firstPos + childCount >= mItemCount) { return; } final int nextPos = firstPos + nextViewIndex; if (nextPos == mLastSeenPos) { post(this); return; } final View nextView = getChildAt(nextViewIndex); final int nextViewHeight = nextView.getHeight(); final int nextViewTop = nextView.getTop(); final int extraScroll = mExtraScroll; if (nextPos < mBoundPos) { smoothScrollBy(Math.max(0, nextViewHeight + nextViewTop - extraScroll), mScrollDuration); mLastSeenPos = nextPos; post(this); } else { if (nextViewTop > extraScroll) { smoothScrollBy(nextViewTop - extraScroll, mScrollDuration); } } break; } case MOVE_UP_POS: { if (firstPos == mLastSeenPos) { post(this); return; } final View firstView = getChildAt(0); if (firstView == null) { return; } final int firstViewTop = firstView.getTop(); final int extraScroll = firstPos > 0 ? mExtraScroll : mListPadding.top; smoothScrollBy(firstViewTop - extraScroll, mScrollDuration); mLastSeenPos = firstPos; if (firstPos > mTargetPos) { post(this); } break; } case MOVE_UP_BOUND: { final int lastViewIndex = getChildCount() - 2; if (lastViewIndex < 0) { return; } final int lastPos = firstPos + lastViewIndex; if (lastPos == mLastSeenPos) { post(this); return; } final View lastView = getChildAt(lastViewIndex); final int lastViewHeight = lastView.getHeight(); final int lastViewTop = lastView.getTop(); final int lastViewPixelsShowing = listHeight - lastViewTop; mLastSeenPos = lastPos; if (lastPos > mBoundPos) { smoothScrollBy(-(lastViewPixelsShowing - mExtraScroll), mScrollDuration); post(this); } else { final int bottom = listHeight - mExtraScroll; final int lastViewBottom = lastViewTop + lastViewHeight; if (bottom > lastViewBottom) { smoothScrollBy(-(bottom - lastViewBottom), mScrollDuration); } } break; } default: break; } } }"}
{"time": "2021-01-25 15:26:56.793819", "score": "1.0", "loss": "0.0", "code": "class T { public void run() { switch(mMode) { case MOVE_DOWN_POS: { final int lastViewIndex = getChildCount() - 1; final int lastPos = firstPos + lastViewIndex; if (lastViewIndex < 0) { return; } if (lastPos == mLastSeenPos) { post(this); return; } final View lastView = getChildAt(lastViewIndex); final int lastViewHeight = lastView.getHeight(); final int lastViewTop = lastView.getTop(); final int lastViewPixelsShowing = listHeight - lastViewTop; final int extraScroll = lastPos < mItemCount - 1 ? mExtraScroll : mListPadding.bottom; smoothScrollBy(lastViewHeight - lastViewPixelsShowing + extraScroll, mScrollDuration); mLastSeenPos = lastPos; if (lastPos < mTargetPos) { post(this); } break; } case MOVE_DOWN_BOUND: { final int nextViewIndex = 1; final int childCount = getChildCount(); if (firstPos == mBoundPos || childCount <= nextViewIndex || firstPos + childCount >= mItemCount) { return; } final int nextPos = firstPos + nextViewIndex; if (nextPos == mLastSeenPos) { post(this); return; } final View nextView = getChildAt(nextViewIndex); final int nextViewHeight = nextView.getHeight(); final int nextViewTop = nextView.getTop(); final int extraScroll = mExtraScroll; if (nextPos < mBoundPos) { smoothScrollBy(Math.max(0, nextViewHeight + nextViewTop - extraScroll), mScrollDuration); mLastSeenPos = nextPos; post(this); } else { if (nextViewTop > extraScroll) { smoothScrollBy(nextViewTop - extraScroll, mScrollDuration); } } break; } case MOVE_UP_POS: { if (firstPos == mLastSeenPos) { post(this); return; } final View firstView = getChildAt(0); if (firstView == null) { return; } final int firstViewTop = firstView.getTop(); final int extraScroll = firstPos > 0 ? mExtraScroll : mListPadding.top; smoothScrollBy(firstViewTop - extraScroll, mScrollDuration); mLastSeenPos = firstPos; if (firstPos > mTargetPos) { post(this); } break; } case MOVE_UP_BOUND: { final int lastViewIndex = getChildCount() - 2; if (lastViewIndex < 0) { return; } final int lastPos = firstPos + lastViewIndex; if (lastPos == mLastSeenPos) { post(this); return; } final View lastView = getChildAt(lastViewIndex); final int lastViewHeight = lastView.getHeight(); final int lastViewTop = lastView.getTop(); final int lastViewPixelsShowing = listHeight - lastViewTop; mLastSeenPos = lastPos; if (lastPos > mBoundPos) { smoothScrollBy(-(lastViewPixelsShowing - mExtraScroll), mScrollDuration); post(this); } else { final int bottom = listHeight - mExtraScroll; final int lastViewBottom = lastViewTop + lastViewHeight; if (bottom > lastViewBottom) { smoothScrollBy(-(bottom - lastViewBottom), mScrollDuration); } } break; } default: break; } } }"}
{"time": "2021-01-25 15:27:38.496027", "score": "0.996", "loss": "0.021", "code": "class T { public void run() { switch(mMode) { case MOVE_DOWN_POS: { final int lastViewIndex = getChildCount() - 1; final int lastPos = firstPos + lastViewIndex; if (lastViewIndex < 0) { return; } if (lastPos == mLastSeenPos) { post(this); return; } final View lastView = getChildAt(lastViewIndex); final int lastViewHeight = lastView.getHeight(); final int lastViewTop = lastView.getTop(); final int lastViewPixelsShowing = listHeight - lastViewTop; final int extraScroll = lastPos < mItemCount - 1 ? mExtraScroll : mListPadding.bottom; smoothScrollBy(lastViewHeight - lastViewPixelsShowing + extraScroll, mScrollDuration); mLastSeenPos = lastPos; if (lastPos < mTargetPos) { post(this); } break; } case MOVE_DOWN_BOUND: { final int nextViewIndex = 1; final int childCount = getChildCount(); if (firstPos == mBoundPos || childCount <= nextViewIndex || firstPos + childCount >= mItemCount) { return; } final int nextPos = firstPos + nextViewIndex; if (nextPos == mLastSeenPos) { post(this); return; } final View nextView = getChildAt(nextViewIndex); final int nextViewHeight = nextView.getHeight(); final int nextViewTop = nextView.getTop(); final int extraScroll = mExtraScroll; if (nextPos < mBoundPos) { smoothScrollBy(Math.max(0, nextViewHeight + nextViewTop - extraScroll), mScrollDuration); mLastSeenPos = nextPos; post(this); } else { if (nextViewTop > extraScroll) { smoothScrollBy(nextViewTop - extraScroll, mScrollDuration); } } break; } case MOVE_UP_POS: { if (firstPos == mLastSeenPos) { post(this); return; } final View firstView = getChildAt(0); if (firstView == null) { return; } final int firstViewTop = firstView.getTop(); final int extraScroll = firstPos > 0 ? mExtraScroll : mListPadding.top; smoothScrollBy(firstViewTop - extraScroll, mScrollDuration); mLastSeenPos = firstPos; if (firstPos > mTargetPos) { post(this); } break; } case MOVE_UP_BOUND: { final int lastViewIndex = getChildCount() - 2; if (lastViewIndex < 0) { return; } final int lastPos = firstPos + lastViewIndex; if (lastPos == mLastSeenPos) { post(this); return; } final View lastView = getChildAt(lastViewIndex); final int lastViewHeight = lastView.getHeight(); final int lastViewTop = lastView.getTop(); final int lastViewPixelsShowing = listHeight - lastViewTop; mLastSeenPos = lastPos; if (lastPos > mBoundPos) { smoothScrollBy(-(lastViewPixelsShowing - mExtraScroll), mScrollDuration); post(this); } else { final int bottom = listHeight - mExtraScroll; final int lastViewBottom = lastViewTop + lastViewHeight; if (bottom > lastViewBottom) { smoothScrollBy(-(bottom - lastViewBottom), mScrollDuration); } } break; } default: break; } } }"}

Minimal simplified code:
class T {
public void run() {                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             }
}


