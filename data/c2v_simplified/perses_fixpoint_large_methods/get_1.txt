
path = /scratch/rabin/data/code2vec/transforms/Methods_Test/java-large/test/droidefense__engine/mods/memapktool/src/main/java/org/jf/dexlib2/analysis/ClassProto_get.java
method_name = get
method_body = @Override public List<Method> get() { List<Method> vtable = Lists.newArrayList(); String superclassType; try { superclassType = getSuperclass(); } catch (UnresolvedClassException ex) { vtable.addAll(((ClassProto) classPath.getClass("Ljava/lang/Object;")).getVtable()); vtableFullyResolved = false; return vtable; } if (superclassType != null) { ClassProto superclass = (ClassProto) classPath.getClass(superclassType); vtable.addAll(superclass.getVtable()); if (!superclass.vtableFullyResolved) { vtableFullyResolved = false; return vtable; } } if (!isInterface()) { addToVtable(getClassDef().getVirtualMethods(), vtable, true, true); Iterable<ClassDef> interfaces = Lists.reverse(Lists.newArrayList(getDirectInterfaces())); List<Method> defaultMethods = Lists.newArrayList(); List<Method> defaultConflictMethods = Lists.newArrayList(); List<Method> mirandaMethods = Lists.newArrayList(); final HashMap<MethodReference, Integer> methodOrder = Maps.newHashMap(); for (ClassDef interfaceDef : interfaces) { for (Method interfaceMethod : interfaceDef.getVirtualMethods()) { int vtableIndex = findMethodIndexInVtable(vtable, interfaceMethod); if (vtableIndex >= 0) { if (interfaceMethodOverrides(interfaceMethod, vtable.get(vtableIndex))) { vtable.set(vtableIndex, interfaceMethod); } } else { int defaultMethodIndex = findMethodIndexInVtable(defaultMethods, interfaceMethod); if (defaultMethodIndex >= 0) { if (!AccessFlags.ABSTRACT.isSet(interfaceMethod.getAccessFlags())) { ClassProto existingInterface = (ClassProto) classPath.getClass(defaultMethods.get(defaultMethodIndex).getDefiningClass()); if (!existingInterface.implementsInterface(interfaceMethod.getDefiningClass())) { Method removedMethod = defaultMethods.remove(defaultMethodIndex); defaultConflictMethods.add(removedMethod); } } continue; } int defaultConflictMethodIndex = findMethodIndexInVtable(defaultConflictMethods, interfaceMethod); if (defaultConflictMethodIndex >= 0) { continue; } int mirandaMethodIndex = findMethodIndexInVtable(mirandaMethods, interfaceMethod); if (mirandaMethodIndex >= 0) { if (!AccessFlags.ABSTRACT.isSet(interfaceMethod.getAccessFlags())) { ClassProto existingInterface = (ClassProto) classPath.getClass(mirandaMethods.get(mirandaMethodIndex).getDefiningClass()); if (!existingInterface.implementsInterface(interfaceMethod.getDefiningClass())) { Method oldMethod = mirandaMethods.remove(mirandaMethodIndex); int methodOrderValue = methodOrder.get(oldMethod); methodOrder.put(interfaceMethod, methodOrderValue); defaultMethods.add(interfaceMethod); } } continue; } if (!AccessFlags.ABSTRACT.isSet(interfaceMethod.getAccessFlags())) { defaultMethods.add(interfaceMethod); methodOrder.put(interfaceMethod, methodOrder.size()); } else { mirandaMethods.add(interfaceMethod); methodOrder.put(interfaceMethod, methodOrder.size()); } } } } Comparator<MethodReference> comparator = new Comparator<MethodReference>() { @Override public int compare(MethodReference o1, MethodReference o2) { return Ints.compare(methodOrder.get(o1), methodOrder.get(o2)); } }; Collections.sort(defaultMethods, comparator); Collections.sort(defaultConflictMethods, comparator); Collections.sort(mirandaMethods, comparator); addToVtable(defaultMethods, vtable, false, false); addToVtable(defaultConflictMethods, vtable, false, false); addToVtable(mirandaMethods, vtable, false, false); } return vtable; }

Trace of simplified code(s):

{"time": "2021-01-25 14:40:05.658386", "score": "1.0", "loss": "0.0", "code": "class T { @Override public List<Method> get() { List<Method> vtable = Lists.newArrayList(); String superclassType; try { superclassType = getSuperclass(); } catch (UnresolvedClassException ex) { vtable.addAll(((ClassProto) classPath.getClass(\"Ljava/lang/Object;\")).getVtable()); vtableFullyResolved = false; return vtable; } if (superclassType != null) { ClassProto superclass = (ClassProto) classPath.getClass(superclassType); vtable.addAll(superclass.getVtable()); if (!superclass.vtableFullyResolved) { vtableFullyResolved = false; return vtable; } } if (!isInterface()) { addToVtable(getClassDef().getVirtualMethods(), vtable, true, true); Iterable<ClassDef> interfaces = Lists.reverse(Lists.newArrayList(getDirectInterfaces())); List<Method> defaultMethods = Lists.newArrayList(); List<Method> defaultConflictMethods = Lists.newArrayList(); List<Method> mirandaMethods = Lists.newArrayList(); final HashMap<MethodReference, Integer> methodOrder = Maps.newHashMap(); for (ClassDef interfaceDef : interfaces) { for (Method interfaceMethod : interfaceDef.getVirtualMethods()) { int vtableIndex = findMethodIndexInVtable(vtable, interfaceMethod); if (vtableIndex >= 0) { if (interfaceMethodOverrides(interfaceMethod, vtable.get(vtableIndex))) { vtable.set(vtableIndex, interfaceMethod); } } else { int defaultMethodIndex = findMethodIndexInVtable(defaultMethods, interfaceMethod); if (defaultMethodIndex >= 0) { if (!AccessFlags.ABSTRACT.isSet(interfaceMethod.getAccessFlags())) { ClassProto existingInterface = (ClassProto) classPath.getClass(defaultMethods.get(defaultMethodIndex).getDefiningClass()); if (!existingInterface.implementsInterface(interfaceMethod.getDefiningClass())) { Method removedMethod = defaultMethods.remove(defaultMethodIndex); defaultConflictMethods.add(removedMethod); } } continue; } int defaultConflictMethodIndex = findMethodIndexInVtable(defaultConflictMethods, interfaceMethod); if (defaultConflictMethodIndex >= 0) { continue; } int mirandaMethodIndex = findMethodIndexInVtable(mirandaMethods, interfaceMethod); if (mirandaMethodIndex >= 0) { if (!AccessFlags.ABSTRACT.isSet(interfaceMethod.getAccessFlags())) { ClassProto existingInterface = (ClassProto) classPath.getClass(mirandaMethods.get(mirandaMethodIndex).getDefiningClass()); if (!existingInterface.implementsInterface(interfaceMethod.getDefiningClass())) { Method oldMethod = mirandaMethods.remove(mirandaMethodIndex); int methodOrderValue = methodOrder.get(oldMethod); methodOrder.put(interfaceMethod, methodOrderValue); defaultMethods.add(interfaceMethod); } } continue; } if (!AccessFlags.ABSTRACT.isSet(interfaceMethod.getAccessFlags())) { defaultMethods.add(interfaceMethod); methodOrder.put(interfaceMethod, methodOrder.size()); } else { mirandaMethods.add(interfaceMethod); methodOrder.put(interfaceMethod, methodOrder.size()); } } } } Comparator<MethodReference> comparator = new Comparator<MethodReference>() { @Override public int compare(MethodReference o1, MethodReference o2) { return Ints.compare(methodOrder.get(o1), methodOrder.get(o2)); } }; Collections.sort(defaultMethods, comparator); Collections.sort(defaultConflictMethods, comparator); Collections.sort(mirandaMethods, comparator); addToVtable(defaultMethods, vtable, false, false); addToVtable(defaultConflictMethods, vtable, false, false); addToVtable(mirandaMethods, vtable, false, false); } return vtable; } }"}
{"time": "2021-01-25 14:43:55.514765", "score": "0.9891", "loss": "0.018", "code": "class T { @Override public List<Method> get() { List<Method> vtable = Lists.newArrayList(); String superclassType; try { superclassType = getSuperclass(); } catch (UnresolvedClassException ex) { vtable.addAll(((ClassProto) classPath.getClass(\"Ljava/lang/Object;\")).getVtable()); vtableFullyResolved = false; return vtable; } } }"}
{"time": "2021-01-25 14:45:50.821511", "score": "0.9954", "loss": "0.0061", "code": "class T { @Override public List<Method> get() { try { superclassType = getSuperclass(); } catch (UnresolvedClassException ex) { vtable.addAll(((ClassProto) classPath.getClass(\"Ljava/lang/Object;\")).getVtable()); vtableFullyResolved = false; return vtable; } } }"}
{"time": "2021-01-25 14:46:32.363584", "score": "0.9979", "loss": "0.0039", "code": "class T { @Override public List<Method> get() { try { superclassType = getSuperclass(); } catch (UnresolvedClassException ex) { vtable.addAll(((ClassProto) classPath.getClass(\"Ljava/lang/Object;\")).getVtable()); vtableFullyResolved = false; return vtable; } } }"}
{"time": "2021-01-25 14:48:42.644383", "score": "0.9883", "loss": "0.022", "code": "class T { @Override public List<Method> get() { { vtable.addAll(((ClassProto) classPath.getClass(\"Ljava/lang/Object;\")).getVtable()); vtableFullyResolved = false; } } }"}
{"time": "2021-01-25 14:50:41.482536", "score": "0.9996", "loss": "0.0005", "code": "class T { @Override public List<Method> get() { { vtableFullyResolved = false; } } }"}
{"time": "2021-01-25 14:52:39.145469", "score": "0.9998", "loss": "0.0002", "code": "class T { @Override public List get() { { vtableFullyResolved = false; } } }"}
{"time": "2021-01-25 14:53:18.758473", "score": "1.0", "loss": "0.0", "code": "class T { List get() { { vtableFullyResolved = false; } } }"}

Minimal simplified code:
class T {
                 List         get()                                                                                                                                                    {                                                                                     vtableFullyResolved = false;                }
}


