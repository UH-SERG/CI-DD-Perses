
path = /scratch/rabin/data/code2vec/transforms/Methods_Test/java-large/test/MariaDB__mariadb-connector-j/src/test/java/org/mariadb/jdbc/failover/TcpProxySocket_run.java
method_name = run
method_body = @Override public void run() { logger.trace("host proxy port " + this.localport + " for " + host + " started"); stop = false; try { try { if (ss.isClosed()) { ss = new ServerSocket(localport); } } catch (BindException b) { try { Thread.sleep(100); } catch (InterruptedException i) { } if (ss.isClosed()) { ss = new ServerSocket(localport); } } final byte[] request = new byte[1024]; byte[] reply = new byte[4096]; while (!stop) { try { client = ss.accept(); final InputStream fromClient = client.getInputStream(); final OutputStream toClient = client.getOutputStream(); try { server = new Socket(host, remoteport); } catch (IOException e) { PrintWriter out = new PrintWriter(new OutputStreamWriter(toClient)); out.println("Proxy server cannot connect to " + host + ":" + remoteport + ":\n" + e); out.flush(); client.close(); continue; } final InputStream fromServer = server.getInputStream(); final OutputStream toServer = server.getOutputStream(); new Thread(() -> { int bytesRead; try { while ((bytesRead = fromClient.read(request)) != -1) { if (delay > 0) { try { Thread.sleep(delay); } catch (InterruptedException e) { e.printStackTrace(); } } toServer.write(request, 0, bytesRead); toServer.flush(); } } catch (IOException e) { } try { toServer.close(); } catch (IOException e) { } }).start(); int bytesRead; try { while ((bytesRead = fromServer.read(reply)) != -1) { try { Thread.sleep(1); } catch (InterruptedException e) { e.printStackTrace(); } toClient.write(reply, 0, bytesRead); toClient.flush(); } } catch (IOException e) { } toClient.close(); } catch (IOException e) { } finally { try { if (server != null) { server.close(); } if (client != null) { client.close(); } } catch (IOException e) { } } } } catch (IOException e) { e.printStackTrace(); } }

Trace of simplified code(s):

{"time": "2021-01-25 09:50:41.818774", "score": "0.9809", "loss": "0.0335", "code": "class T { @Override public void run() { logger.trace(\"host proxy port \" + this.localport + \" for \" + host + \" started\"); stop = false; try { try { if (ss.isClosed()) { ss = new ServerSocket(localport); } } catch (BindException b) { try { Thread.sleep(100); } catch (InterruptedException i) { } if (ss.isClosed()) { ss = new ServerSocket(localport); } } final byte[] request = new byte[1024]; byte[] reply = new byte[4096]; while (!stop) { try { client = ss.accept(); final InputStream fromClient = client.getInputStream(); final OutputStream toClient = client.getOutputStream(); try { server = new Socket(host, remoteport); } catch (IOException e) { PrintWriter out = new PrintWriter(new OutputStreamWriter(toClient)); out.println(\"Proxy server cannot connect to \" + host + \":\" + remoteport + \":\n\" + e); out.flush(); client.close(); continue; } final InputStream fromServer = server.getInputStream(); final OutputStream toServer = server.getOutputStream(); new Thread(() -> { int bytesRead; try { while ((bytesRead = fromClient.read(request)) != -1) { if (delay > 0) { try { Thread.sleep(delay); } catch (InterruptedException e) { e.printStackTrace(); } } toServer.write(request, 0, bytesRead); toServer.flush(); } } catch (IOException e) { } try { toServer.close(); } catch (IOException e) { } }).start(); int bytesRead; try { while ((bytesRead = fromServer.read(reply)) != -1) { try { Thread.sleep(1); } catch (InterruptedException e) { e.printStackTrace(); } toClient.write(reply, 0, bytesRead); toClient.flush(); } } catch (IOException e) { } toClient.close(); } catch (IOException e) { } finally { try { if (server != null) { server.close(); } if (client != null) { client.close(); } } catch (IOException e) { } } } } catch (IOException e) { e.printStackTrace(); } } }"}
{"time": "2021-01-25 09:51:33.907282", "score": "0.3314", "loss": "1.8159", "code": "class T { @Override public void run() { } }"}
{"time": "2021-01-25 09:51:55.200853", "score": "0.3314", "loss": "1.8159", "code": "class T { @Override void run() { } }"}

Minimal simplified code:
class T {
@Override        void run() {                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    }
}


