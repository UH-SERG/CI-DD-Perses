
path = /scratch/rabin/data/code2vec/transforms/Methods_Test/java-large/test/yahoo__FEL/src/main/java/it/cnr/isti/hpc/Word2VecCompress_main.java
method_name = main
method_body = public static void main(String[] args) throws Exception { SimpleJSAP jsap = new SimpleJSAP(Word2VecCompress.class.getName(), "Creates a compressed representation of quantized word2vec vectors", new Parameter[] { new UnflaggedOption("input", JSAP.STRING_PARSER, true, "Input file"), new UnflaggedOption("output", JSAP.STRING_PARSER, false, "Compressed version"), new Switch("check", JSAP.NO_SHORTFLAG, "check", "Check correctness of output") }); JSAPResult jsapResult = jsap.parse(args); if (jsap.messagePrinted()) return; String input_filename = jsapResult.getString("input"); String output_filename = jsapResult.getString("output", null); int numWords, vectorSize; float quantizationFactor; List<String> indexToWord; int[] entries; long[] columnAbsSum; ProgressLogger pl = new ProgressLogger(logger); try (final BufferedReader lines = new BufferedReader(new FileReader(input_filename))) { String[] header = lines.readLine().split("\t"); numWords = Integer.parseInt(header[0]); vectorSize = Integer.parseInt(header[1]); quantizationFactor = Float.parseFloat(header[2]); pl.expectedUpdates = numWords; pl.start("Reading the dictionary"); indexToWord = new ArrayList<>(); for (int i = 0; i < numWords; ++i) { pl.lightUpdate(); indexToWord.add(lines.readLine().trim()); } pl.done(); entries = new int[numWords * vectorSize]; columnAbsSum = new long[vectorSize]; pl.expectedUpdates = numWords; pl.start("Reading the vectors"); for (int i = 0; i < numWords; ++i) { pl.lightUpdate(); String[] lineEntries = lines.readLine().split(" "); for (int col = 0; col < vectorSize; ++col) { int entry = Integer.parseInt(lineEntries[col]); entries[i * vectorSize + col] = entry; columnAbsSum[col] += Fast.int2nat(entry) + 1; } } pl.done(); } int[] golombModuli = new int[vectorSize]; for (int col = 0; col < vectorSize; ++col) { int m = 0; if (columnAbsSum[col] > numWords) { double f = ((double) numWords) / columnAbsSum[col]; m = (int) Math.ceil(Math.log(2.0 - f) / -Math.log(1.0 - f)); } golombModuli[col] = m; } ShiftAddXorSignedStringMap dictionaryHash = new ShiftAddXorSignedStringMap(indexToWord.iterator(), new MinimalPerfectHashFunction.Builder<CharSequence>().keys(indexToWord).transform(TransformationStrategies.utf16()).build()); int[] permutation = new int[numWords]; for (int i = 0; i < numWords; ++i) { int newPos = dictionaryHash.get(indexToWord.get(i)).intValue(); permutation[newPos] = i; } FastByteArrayOutputStream oa = new FastByteArrayOutputStream(); OutputBitStream obs = new OutputBitStream(oa, 0); final LongArrayList endpoints = new LongArrayList(); pl.expectedUpdates = numWords; pl.start("Compressing the vectors"); for (int i = 0; i < numWords; ++i) { pl.lightUpdate(); endpoints.add(obs.writtenBits()); int rowStart = permutation[i] * vectorSize; for (int col = 0; col < vectorSize; ++col) { int entry = entries[rowStart + col]; obs.writeGolomb(Fast.int2nat(entry), golombModuli[col]); } } pl.done(); obs.close(); while (oa.length() % 4 != 0) { oa.write(0); } oa.trim(); double bps = 8.0 * oa.array.length / entries.length; logger.info("Overall vector bit streams: {} bytes, {} bps", oa.array.length, bps); System.out.println(bps); EliasFanoMonotoneLongBigList efEndpoints = new EliasFanoMonotoneLongBigList(endpoints); Word2VecCompress word2vec = new Word2VecCompress(numWords, vectorSize, quantizationFactor, oa.array, efEndpoints, dictionaryHash, golombModuli); if (output_filename != null) { BinIO.storeObject(word2vec, output_filename); } if (jsapResult.getBoolean("check")) { pl.expectedUpdates = numWords; pl.start("Checking the output"); for (int i = 0; i < numWords; ++i) { pl.lightUpdate(); int[] vec = word2vec.getInt(indexToWord.get(i)); for (int col = 0; col < vectorSize; ++col) { int expected = entries[i * vectorSize + col]; int got = vec[col]; if (expected != got) { logger.error("Row {}, Column {}: Expected {}, got {}", i, col, expected, got); System.exit(1); } } } pl.done(); } }

topk path-contexts for sub-token: main
[0.1566] args,VariableDeclaratorId0|Parameter|MethodDeclaration|BlockStmt|TryStmt|BlockStmt|ExpressionStmt|VariableDeclarationExpr|ArrayBracketPair2,[]
[0.1519] args,VariableDeclaratorId0|Parameter|MethodDeclaration|BlockStmt|ExpressionStmt|VariableDeclarationExpr|ArrayBracketPair2,[]
[0.1293] args,VariableDeclaratorId0|Parameter|MethodDeclaration|BlockStmt|ExpressionStmt|VariableDeclarationExpr|VariableDeclarator|VariableDeclaratorId0,pl
[0.1094] args,VariableDeclaratorId0|Parameter|MethodDeclaration|BlockStmt|ExpressionStmt|VariableDeclarationExpr|PrimitiveType0,long
[0.1078] args,VariableDeclaratorId0|Parameter|MethodDeclaration|BlockStmt|IfStmt|BlockStmt|ForStmt|VariableDeclarationExpr|PrimitiveType0,int
[0.0499] args,VariableDeclaratorId0|Parameter|MethodDeclaration|BlockStmt|ExpressionStmt|MethodCallExpr0|NameExpr3,start
[0.0474] args,VariableDeclaratorId0|Parameter|MethodDeclaration|BlockStmt|ExpressionStmt|VariableDeclarationExpr|VariableDeclarator|VariableDeclaratorId0,num|words
[0.0321] args,VariableDeclaratorId0|Parameter|MethodDeclaration|BlockStmt|ForStmt|BinaryExpr:less|NameExpr0,col
[0.0238] args,VariableDeclaratorId0|Parameter|MethodDeclaration|BlockStmt|TryStmt|BlockStmt|ExpressionStmt|AssignExpr:assign0|NameExpr1,num|words
[0.0108] [],ArrayBracketPair2|Parameter|MethodDeclaration|BlockStmt|IfStmt|BlockStmt|ExpressionStmt|MethodCallExpr0|StringLiteralExpr2,checking|the|output

topk terminals for sub-token: main
['args', '[]', 'args', '[]', 'args', 'pl', 'args', 'long', 'args', 'int', 'args', 'start', 'args', 'num|words', 'args', 'col', 'args', 'num|words', '[]', 'checking|the|output']

