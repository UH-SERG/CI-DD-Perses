
path = /scratch/rabin/data/code2vec/transforms/Methods_Test/java-large/test/codefollower__Tomcat-Research/java/org/apache/catalina/servlets/CGIServlet_run.java
method_name = run
method_body = protected void run() throws IOException { if (!isReady()) { throw new IOException(this.getClass().getName() + ": not ready to run."); } if (debug >= 1) { log("runCGI(envp=[" + env + "], command=" + command + ")"); } if ((command.indexOf(File.separator + "." + File.separator) >= 0) || (command.indexOf(File.separator + "..") >= 0) || (command.indexOf(".." + File.separator) >= 0)) { throw new IOException(this.getClass().getName() + "Illegal Character in CGI command " + "path ('.' or '..') detected. Not " + "running CGI [" + command + "]."); } Runtime rt = null; BufferedReader cgiHeaderReader = null; InputStream cgiOutput = null; BufferedReader commandsStdErr = null; Thread errReaderThread = null; BufferedOutputStream commandsStdIn = null; Process proc = null; int bufRead = -1; List<String> cmdAndArgs = new ArrayList<>(); if (cgiExecutable.length() != 0) { cmdAndArgs.add(cgiExecutable); } if (cgiExecutableArgs != null) { cmdAndArgs.addAll(cgiExecutableArgs); } cmdAndArgs.add(command); cmdAndArgs.addAll(params); try { rt = Runtime.getRuntime(); proc = rt.exec(cmdAndArgs.toArray(new String[cmdAndArgs.size()]), hashToStringArray(env), wd); String sContentLength = env.get("CONTENT_LENGTH"); if (!"".equals(sContentLength)) { commandsStdIn = new BufferedOutputStream(proc.getOutputStream()); IOTools.flow(stdin, commandsStdIn); commandsStdIn.flush(); commandsStdIn.close(); } boolean isRunning = true; commandsStdErr = new BufferedReader(new InputStreamReader(proc.getErrorStream())); final BufferedReader stdErrRdr = commandsStdErr; errReaderThread = new Thread() { @Override public void run() { sendToLog(stdErrRdr); } }; errReaderThread.start(); InputStream cgiHeaderStream = new HTTPHeaderInputStream(proc.getInputStream()); cgiHeaderReader = new BufferedReader(new InputStreamReader(cgiHeaderStream)); while (isRunning) { try { String line = null; while (((line = cgiHeaderReader.readLine()) != null) && !("".equals(line))) { if (debug >= 2) { log("runCGI: addHeader(\"" + line + "\")"); } if (line.startsWith("HTTP")) { response.setStatus(getSCFromHttpStatusLine(line)); } else if (line.indexOf(":") >= 0) { String header = line.substring(0, line.indexOf(":")).trim(); String value = line.substring(line.indexOf(":") + 1).trim(); if (header.equalsIgnoreCase("status")) { response.setStatus(getSCFromCGIStatusHeader(value)); } else { response.addHeader(header, value); } } else { log("runCGI: bad header line \"" + line + "\""); } } byte[] bBuf = new byte[2048]; OutputStream out = response.getOutputStream(); cgiOutput = proc.getInputStream(); try { while ((bufRead = cgiOutput.read(bBuf)) != -1) { if (debug >= 4) { log("runCGI: output " + bufRead + " bytes of data"); } out.write(bBuf, 0, bufRead); } } finally { if (bufRead != -1) { while ((bufRead = cgiOutput.read(bBuf)) != -1) { } } } proc.exitValue(); isRunning = false; } catch (IllegalThreadStateException e) { try { Thread.sleep(500); } catch (InterruptedException ignored) { } } } } catch (IOException e) { log("Caught exception " + e); throw e; } finally { if (cgiHeaderReader != null) { try { cgiHeaderReader.close(); } catch (IOException ioe) { log("Exception closing header reader " + ioe); } } if (cgiOutput != null) { try { cgiOutput.close(); } catch (IOException ioe) { log("Exception closing output stream " + ioe); } } if (errReaderThread != null) { try { errReaderThread.join(stderrTimeout); } catch (InterruptedException e) { log("Interupted waiting for stderr reader thread"); } } if (debug > 4) { log("Running finally block"); } if (proc != null) { proc.destroy(); proc = null; } } }

topk path-contexts for sub-token: run
[0.0506] METHOD_NAME,NameExpr1|MethodDeclaration|BlockStmt|IfStmt|BlockStmt|ThrowStmt|ObjectCreationExpr|BinaryExpr:plus|StringLiteralExpr1,:|not|ready|to|run
[0.0505] override,NameExpr0|MarkerAnnotationExpr|MethodDeclaration|NameExpr2,METHOD_NAME
[0.0502] this,ThisExpr0|MethodCallExpr0|MethodCallExpr|BinaryExpr:plus|StringLiteralExpr1,:|not|ready|to|run
[0.0417] is|ready,NameExpr1|MethodCallExpr|UnaryExpr:not|IfStmt|BlockStmt|ThrowStmt|ObjectCreationExpr|BinaryExpr:plus|StringLiteralExpr1,:|not|ready|to|run
[0.0351] ioe,VariableDeclaratorId0|Parameter|CatchClause|BlockStmt|ExpressionStmt|MethodCallExpr0|BinaryExpr:plus|StringLiteralExpr0,exception|closing|output|stream
[0.0320] ioe,VariableDeclaratorId0|Parameter|CatchClause|BlockStmt|ExpressionStmt|MethodCallExpr0|BinaryExpr:plus|StringLiteralExpr0,exception|closing|header|reader
[0.0289] err|reader|thread,NameExpr0|BinaryExpr:notEquals|IfStmt|BlockStmt|IfStmt|BlockStmt|ExpressionStmt|MethodCallExpr0|StringLiteralExpr1,running|finally|block
[0.0269] is|running,NameExpr0|AssignExpr:assign|BooleanLiteralExpr1,false
[0.0253] e,VariableDeclaratorId0|Parameter|CatchClause|BlockStmt|ExpressionStmt|MethodCallExpr0|BinaryExpr:plus|StringLiteralExpr0,caught|exception
[0.0217] is|running,NameExpr0|WhileStmt|BlockStmt|TryStmt|BlockStmt|ExpressionStmt|VariableDeclarationExpr|ClassOrInterfaceType0,string

topk terminals for sub-token: run
['METHOD_NAME', ':|not|ready|to|run', 'override', 'METHOD_NAME', 'this', ':|not|ready|to|run', 'is|ready', ':|not|ready|to|run', 'ioe', 'exception|closing|output|stream', 'ioe', 'exception|closing|header|reader', 'err|reader|thread', 'running|finally|block', 'is|running', 'false', 'e', 'caught|exception', 'is|running', 'string']

