
path = /scratch/rabin/data/code2vec/transforms/Methods_Test/java-large/test/codefollower__Tomcat-Research/modules/tomcat-lite/java/org/apache/tomcat/lite/io/NioThread_run.java
method_name = run
method_body = public void run() { int sloops = 0; if (debug) { log.info("Start NIO thread, daemon=" + daemon); } while (running) { try { loops.incrementAndGet(); processPending(); long now = System.currentTimeMillis(); if (nextWakeup < now) { updateSleepTimeAndProcessTimeouts(now); } int selected = selector.select(sleepTime); lastWakeup = System.currentTimeMillis(); long slept = lastWakeup - now; if (debugWakeup && selected == 0) { if (sleepTime < maxSleep - 1000) { log.info("Wakeup " + selected + " " + slept + " " + sleepTime); } } if (slept < 10 && selected == 0) { if (sloops > 50) { sloops = 0; log.severe("Looping !"); resetSelector(); } sloops++; } if (selected != 0) { sloops = 0; int callbackCnt = 0; Set<SelectionKey> sel = selector.selectedKeys(); Iterator<SelectionKey> i = sel.iterator(); while (i.hasNext()) { callbackCnt++; long beforeCallback = System.currentTimeMillis(); SelectionKey sk = i.next(); i.remove(); boolean valid = sk.isValid(); int readyOps = (valid) ? sk.readyOps() : 0; NioChannel ch = (NioChannel) sk.attachment(); if (debugWakeup) { log.info("Wakeup selCnt=" + selected + " slept=" + (lastWakeup - now) + " ready: " + readyOps + " v=" + sk.isValid() + " ch=" + ch); } if (ch == null) { log.severe("Missing channel"); sk.cancel(); continue; } if (ch.selKey != sk) { log.severe("Invalid state, selKey doesn't match "); ch.selKey = sk; } if (ch.channel != sk.channel()) { ch.channel = sk.channel(); log.severe("Invalid state, channel doesn't match "); } if (!sk.isValid()) { if (debug) { log.info("!isValid, closed socket " + ch); } ch.close(); continue; } try { int ready = sk.readyOps(); if (sk.isValid() && sk.isAcceptable()) { handleAccept(ch, sk); } if (sk.isValid() && sk.isConnectable()) { sk.interestOps(sk.interestOps() & ~SelectionKey.OP_CONNECT); SocketChannel sc = (SocketChannel) sk.channel(); handleConnect(ch, sc); } if (sk.isValid() && sk.isWritable()) { sk.interestOps(sk.interestOps() & ~SelectionKey.OP_WRITE); ch.writeInterest = false; handleDataWriteable(ch); } if (sk.isValid() && sk.isReadable()) { handleReadable(ch); } long callbackTime = System.currentTimeMillis() - beforeCallback; if (callbackTime > 250) { log.warning("Callback too long ! ops=" + ready + " time=" + callbackTime + " ch=" + ch + " " + callbackCnt); } if (callbackTime > maxCallbackTime) { maxCallbackTime = callbackTime; } callbackCount.incrementAndGet(); this.callbackTotalTime.addAndGet(callbackTime); } catch (Throwable t) { log.log(Level.SEVERE, "SelectorThread: Channel error, closing", t); ch.lastException = t; ch.close(); } } sel.clear(); } } catch (Throwable e) { log.log(Level.SEVERE, "SelectorThread: Error in select", e); } } log.info("SelectorThread done"); }

topk path-contexts for sub-token: run
[0.2047] void,VoidType0|MethodDeclaration|BlockStmt|WhileStmt|BlockStmt|TryStmt|CatchClause|Parameter|ClassOrInterfaceType1,throwable
[0.1051] wakeup,StringLiteralExpr0|BinaryExpr:plus|BinaryExpr:plus|BinaryExpr:plus|NameExpr1,slept
[0.0685] running,NameExpr0|WhileStmt|BlockStmt|TryStmt|BlockStmt|ExpressionStmt|VariableDeclarationExpr|VariableDeclarator|VariableDeclaratorId0,selected
[0.0679] METHOD_NAME,NameExpr1|MethodDeclaration|BlockStmt|WhileStmt|BlockStmt|TryStmt|CatchClause|Parameter|ClassOrInterfaceType1,throwable
[0.0587] wakeup|sel|cnt,StringLiteralExpr0|BinaryExpr:plus|NameExpr1,selected
[0.0334] void,VoidType0|MethodDeclaration|NameExpr1,METHOD_NAME
[0.0305] interest|ops,NameExpr2|MethodCallExpr|BinaryExpr:binAnd2|UnaryExpr:inverse|FieldAccessExpr0|NameExpr2,op|connect
[0.0216] void,VoidType0|MethodDeclaration|BlockStmt|ExpressionStmt|VariableDeclarationExpr|VariableDeclarator|IntegerLiteralExpr1,0
[0.0192] int,PrimitiveType0|VariableDeclarationExpr|VariableDeclarator|MethodCallExpr1|NameExpr2,ready|ops
[0.0175] sk,NameExpr0|MethodCallExpr|BinaryExpr:binAnd2|UnaryExpr:inverse|FieldAccessExpr0|NameExpr2,op|write

topk terminals for sub-token: run
['void', 'throwable', 'wakeup', 'slept', 'running', 'selected', 'METHOD_NAME', 'throwable', 'wakeup|sel|cnt', 'selected', 'void', 'METHOD_NAME', 'interest|ops', 'op|connect', 'void', '0', 'int', 'ready|ops', 'sk', 'op|write']

